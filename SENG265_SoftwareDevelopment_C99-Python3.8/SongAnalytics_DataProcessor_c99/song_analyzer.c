/** @file music_manager.c
 *  @brief A small program to analyze songs data.
 *  @author Mike Z.
 *  @author Felipe R.
 *  @author Hausi M.
 *  @author Juan G.
 *  @author Angadh S.
 *  @author lexph
 *
 * References:
 * [1] Function comment blocks were generated by Copilot, and verified by lexph.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdbool.h>
#include "list.h"

#define MAX_LINE_LEN 80

/**
 * @brief Serves as an incremental counter for navigating the list.
 *
 * @param p The pointer of the node to print.
 * @param arg The pointer of the index.
 *
 */
void inccounter(node_t *p, void *arg)
{
    int *ip = (int *)arg;
    (*ip)++;
}

/** [1]
 * @brief Prints the data of a node.
 *
 * This function formats and prints the data of a node. The format of the output can be customized by passing a format string as `arg`.
 *
 * @param p Pointer to the node to be printed.
 * @param arg Optional argument that specifies the format of the output. If `arg` is NULL, a default format is used.
 */
void print_node(node_t *p, void *arg)
{
    char *fmt = NULL;
    char *date_fmt = "%Y-%m-%d";
    if(arg == NULL)
        fmt = "%s,%s,%s,%u,%lu,%lu,%lu\n";
    else
        fmt = (char *)arg;

    char buffer[MAX_WORD_LEN];
    strftime(buffer, sizeof(buffer), date_fmt, &p->date_);

    printf(fmt, buffer, p->track_name, p->artist, p->artist_count,  
           p->in_apple_playlists, p->streams, p->in_spotify_playlists);
}

/**
 * @brief Allows to print each node in the list.
 *
 * @param l The first node in the list
 *
 */
void analysis(node_t *l)
{
    int len = 0;

    apply(l, inccounter, &len);
    printf("Number of records: %d\n", len);

    apply(l, print_node, NULL);
}

/** [1]
 * @brief Parses command-line arguments.
 *
 * This function parses command-line arguments and assigns them to the appropriate variables.
 *
 * @param argc The number of command-line arguments.
 * @param argv The array of command-line arguments.
 * @param infile Pointer to the input file pointer.
 * @param filter Pointer to the filter string.
 * @param filter_value Pointer to the filter value string.
 * @param order_by_value Pointer to the order by value string.
 * @param order_by_direction Pointer to the order by direction string.
 * @param limit Pointer to the limit string.
 */
void parse_arguments(int argc, char *argv[], FILE **infile, char **filter, char **filter_value,\
                char **order_by_value, char **order_by_direction, char **limit)
{
    char *token = NULL;
    for(int i = 1; i < argc; i++) 
    {
        token = strtok(argv[i], "\"= ");
        // printf("Token: %s\n", token);
    
        if (strcmp(token, "--data") == 0)
        {
            token = strtok(NULL, "\"");
            *infile = fopen(token, "r");
            if (*infile == NULL) {
                printf("Error: could not open file '%s'\n", token);
                exit(1);
            }
        }
        else if(strcmp(token, "--filter") == 0) 
        {
            token = strtok(NULL, "\"");
            *filter = token;
        }
        else if (strcmp(token, "--value") == 0)
        {
            token = strtok(NULL, "\"");
            *filter_value = token;
        }
        else if (strcmp(token, "--order_by") == 0)
        {
            token = strtok(NULL, "\"");
            *order_by_value = token;
        }
        else if (strcmp(token, "--order") == 0)
        {
            token = strtok(NULL, "\"");
            *order_by_direction = token;
        }
        else if (strcmp(token, "--limit") == 0)
        {
            token = strtok(NULL, "\"");
            *limit = token;
        }
        else
        {
            printf("Error: argument: '%s' not valid.\n", token);
	        exit(1);
        }
    }
}

/** [1]
 * @brief Parses a line of input and fills a record with the parsed data.
 *
 * This function tokenizes a line of input based on commas. It handles cases where a token is split across two lines.
 * It fills the fields of a `node_t` record with the parsed tokens. The specific fields that are filled depend on the value of `order_by_value`.
 * If a token is split across two lines, the function reads the next line from the file to complete the token.
 *
 * @param record Pointer to the `node_t` record to be filled.
 * @param line Pointer to the line of input to be parsed.
 * @param file Pointer to the file to read from if a token is split across two lines.
 */
void fill_record(node_t *record, char *line, FILE *file)
{
    char buffer[200];
    char *p_buffer = NULL;
    bool is_final_token=false;
    unsigned int token_count = 0; 
    char *token=NULL;
    int chars_read=0;
    bool line_starts_with_comma = line[0] == ',';
    bool line_ends_with_comma = line[strlen(line)-1] == ',';

    if(line_starts_with_comma) 
    {   
        token = ""; // an empty string
        chars_read += 1;
        line = line+1;
        fill_node(record, token, token_count++);
    }
    
    while(!is_final_token && token_count<9) {
        
        /*----Check For Line Split Leaving Comma at Start----*/
        if(line[0]==',') {
            memmove(&line[0], &line[1], strlen(line)); // remove comma, shift left
            fill_node(record, p_buffer, token_count++); // fill last complete token from buffer
            p_buffer = NULL;
        }

        /*----Check For Incomplete Token----*/
        if(p_buffer!=NULL && line_ends_with_comma == false) { 
            
            char* tokenEnd = strtok(line, ",");
            chars_read = strlen(tokenEnd)+1; // characters read in current fgets call
            token = strcat(buffer, tokenEnd); // complete the token
            p_buffer = NULL; 
        }else { // Complete Token
            token = strtok(line, ",");
            chars_read = strlen(token)+1;
        }
        
        /*----Cycle Through Tokens in Input Line----*/
        while(token!=NULL) {
            // first token is good, input into record, increment token_count post call.
            // only output if read tokens up to MAX_LINE_LEN or the last token in line has '\n'
            if(chars_read < MAX_LINE_LEN || token[strlen(token)-1]=='\n') {
                fill_node(record, token, token_count++);
            }
            // Check if outputted the last token in 
            if(token[strlen(token)-1]=='\n') {
                is_final_token = true;
            }
            strcpy(buffer, token); // update buffer incase incomplete token
            token = strtok(NULL, ","); // update token
            
            if(token!=NULL) {
                chars_read += strlen(token)+1;
            }
        }
        /*----Check For Incomplete Token, Set p_buffer to Buffer If Incomplete----*/
        if(!is_final_token && buffer[0]!='\0')  // last token didn't contain newline, and the buffer has contents
        {
            p_buffer = buffer;
            fgets(line, MAX_LINE_LEN, file); // retrieve next part of the record
        }
    }
}

/** 
 * @brief Prints commandline arguments
 * 
 * Tester function for verifying commandline arguments
 */
void print_variables(char *filter, char *filter_value, char *order_by_value, 
                     char *order_by_direction, char *limit, FILE *infile) {
    printf("Filter: %s\n", filter);
    printf("Filter Value: %s\n", filter_value);
    printf("Order By Value: %s\n", order_by_value);
    printf("Order By Direction: %s\n", order_by_direction);
    printf("Limit: %s\n", limit);
    printf("Infile: %p\n", infile);
}

/** [1]
 * @brief Checks if a record matches a filter.
 *
 * @param record The record to check.
 * @param filter The type of filter.
 * @param filter_value The value to filter by.
 * @return bool True if the record matches the filter, false otherwise.
 */
bool is_filter(node_t *record, char *filter, char *filter_value)
{
    if(strcmp(filter, "ARTIST")==0) 
        return strstr(record->artist, filter_value)!=NULL? true : false;

    else if(strcmp(filter, "YEAR")==0)    // tm_year value is years since 1900.
        return atoi(filter_value)-1900 == record->date_.tm_year; 

    else
        return false;
}

/** [1]
 * @brief Returns a comparison function based on order_by_value.
 *
 * @param order_by_value The value determining which comparison function to return.
 * @return Function pointer to the appropriate comparison function.
 */
int (*get_compare(char *order_by_value))(node_t *, node_t *, int) {

    if (strcmp(order_by_value, "STREAMS") == 0) 
        return compare_by_streams;

    else if (strcmp(order_by_value, "NO_APPLE_PLAYLISTS") == 0) 
        return compare_by_apple_playlists;

    else if (strcmp(order_by_value, "NO_SPOTIFY_PLAYLISTS") == 0) 
        return compare_by_spotify_playlists;
        
    else 
        return NULL;
    
}

/** [1]
 * @brief Orders a list based on a comparison function.
 *
 * @param list The list to order.
 * @param order_by_direction The direction to order the list in.
 * @param compare The comparison function to use.
 * @return node_t* Pointer to the head of the ordered list.
 */
node_t *order_list(node_t *list, char *order_by_direction, int (*compare)(node_t *, node_t *, int))
{
    int order = strcmp(order_by_direction, "DES") == 0 ? -1 : 1;
    node_t *sorted_list = NULL;
    node_t *node = list;
    while (node != NULL) 
    {
        node_t *next_node = node->next;
        node->next = NULL;  
        sorted_list = add_inorder(sorted_list, node, compare, order);
        node = next_node;
    }
    return sorted_list;
}

/** [1]
 * @brief Writes a header to a file based on a given value.
 *
 * Opens a file, writes a specific header line based on `order_by_value`, then reopens the file in append mode.
 *
 * @param order_by_value Determines the header line to write.
 * @return FILE* Pointer to the opened file.
 */
FILE *write_header_to_file(char * order_by_value)
{
    FILE *outfile = NULL;
    if(order_by_value!=NULL)
    {
        if(strcmp(order_by_value, "STREAMS")==0)
        {
            outfile = fopen("output.csv", "w");
            fputs("released,track_name,artist(s)_name,streams\n",outfile);
            fclose(outfile);
        }else if(strcmp(order_by_value,"NO_SPOTIFY_PLAYLISTS")==0){
            outfile = fopen("output.csv", "w");
            fputs("released,track_name,artist(s)_name,in_spotify_playlists\n",outfile);
            fclose(outfile);
        }else if(strcmp(order_by_value, "NO_APPLE_PLAYLISTS")==0){
            outfile = fopen("output.csv", "w");
            fputs("released,track_name,artist(s)_name,in_apple_playlists\n",outfile);
            fclose(outfile);
        }else {
            exit(-1);
        }
    }outfile=fopen("output.csv", "a");
    return outfile;
}

/** [1]
 * @brief Writes node data to a file.
 *
 * Writes the date, track name, and artist of the node to the file. Also writes additional data based on `order_by_value`.
 *
 * @param current_node Pointer to the node to be written to the file.
 * @param outfile Pointer to the file.
 * @param order_by_value String indicating the additional data to write.
 */
void write_to_file(node_t *current_node, FILE *outfile, char *order_by_value)
{
    char buffer[11];
    strftime(buffer, 11, "%Y-%-m-%-d", &(current_node->date_));
    fprintf(outfile, "%s,%s,%s",
            buffer,
            current_node->track_name,
            current_node->artist);

    if(strcmp(order_by_value, "STREAMS")==0) 
        fprintf(outfile, ",%lu\n", current_node->streams);

    else if(strcmp(order_by_value, "NO_APPLE_PLAYLISTS")==0) 
        fprintf(outfile, ",%lu\n", current_node->in_apple_playlists); 

    else if(strcmp(order_by_value, "NO_SPOTIFY_PLAYLISTS")==0) 
        fprintf(outfile, ",%lu\n", current_node->in_spotify_playlists);
        
    else
        printf("Something went wrong?\n");
}

/** [1]
 * @brief Frees a singly linked list.
 *
 * Iterates over the list, freeing each node. Sets `next` of each node to `NULL` before freeing.
 *
 * @param list Pointer to the head of the list.
 */
void free_list(node_t *list) {
    node_t *temp;

    while (list != NULL) {
        temp = list;
        list = list->next;
        free(temp);
    }
}

/** [1]
 * @brief Entry point for a data processing program.
 *
 * This program processes a data file based on command line arguments. It filters and sorts the data, then writes the output to a file.
 *
 * @param argc The count of command-line arguments.
 * @param argv The array containing the command-line arguments.
 *
 * @return int Returns 0 if the program finishes successfully, and 1 if an error occurs.
 */

int main(int argc, char *argv[])
{
    char *line = NULL;
    node_t *list = NULL;
    char *filter = NULL;
    char *filter_value = NULL;
    char *order_by_value = NULL;
    char *order_by_direction = NULL;
    char *limit = NULL;
    FILE *infile = NULL;
    FILE *outfile = NULL;

    line = (char *)malloc(sizeof(char) * MAX_LINE_LEN);
    strcpy(line, "this is the starting point for A3.");

    /*--Parse commandline arguments, assign to pointers--*/
    parse_arguments(argc, argv, &infile, &filter, &filter_value, 
                    &order_by_value, &order_by_direction, &limit);

    /*--Set compare function for sorting order--*/
    int (*compare)(node_t *, node_t *, int);
    if(order_by_value!=NULL && order_by_direction!=NULL)
        compare = get_compare(order_by_value);

    /*--Skip header row from data file--*/
    for(fgets(line, MAX_LINE_LEN, infile); line[strlen(line)-1]!='\n';fgets(line, MAX_LINE_LEN, infile));

    /*--Create blank record on heap, fill record, add to list if it matches filter--*/
    while(fgets(line, MAX_LINE_LEN, infile)!=NULL) 
    {   
        node_t *record = new_node(); 
        fill_record(record, line, infile);
        if(is_filter(record, filter, filter_value))    
            list = add_end(list, record);
    }

    /*--Create a new ordered list, assigning it to final_list--*/
    node_t *final_list = order_list(list, order_by_direction, compare);

    /*--Write header row to file, return outfile in append mode--*/
    outfile = write_header_to_file(order_by_value);
    
    /*--Output Final List--*/
    size_t limit_count =0;
    node_t *node = final_list;  
    while (node != NULL) {
        write_to_file(node, outfile, order_by_value);
        node = node->next;
        limit_count++;
        if(limit!=NULL && limit_count == atoi(limit))
            break;
    }

    /*--Free Memory--*/
    free_list(list);
    free_list(final_list);
    free(line);
    fclose(infile);
    fclose(outfile);

    exit(0);
}
