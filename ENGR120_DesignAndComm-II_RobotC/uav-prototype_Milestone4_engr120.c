#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LeftIR,         sensorReflection)
#pragma config(Sensor, in2,    RightIR,        sensorReflection)
#pragma config(Sensor, dgtl1,  SwitchRight,    sensorTouch)
#pragma config(Sensor, dgtl2,  SwitchLeft,     sensorTouch)
#pragma config(Sensor, dgtl3,  button1,        sensorTouch)
#pragma config(Sensor, dgtl4,  LED_1,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  Sonar_Sensor,   sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  LED_2,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  LED_3,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED_4,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LED_5,          sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LED_6,          sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  motorRight,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  motorLeft,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorRight,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           motorCable,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorCrane,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define EXERCISE_NUMBER 	1
#define abs(X) ((X < 0) ? -1 * X : X)
	bool button1_pushed; //flag to store start button for testing
	bool IR_FirstHit_Left;  //fag to store Left IR first hit
	bool IR_FirstHit_Right; //fag to store Right IR first hit
	bool SwitchRight_pushed; //flag to store buttonRight input
	bool SwitchLeft_pushed; //flag to store buttonLeft input
	bool Bumper_connection_pushed;//flag to store switch connection input
	int Direction; // 1 or 0 value for what side the wall is relative to the robot
	int Left_Low_G = 4096; // global variable for Left Low IR value
	int Right_Low_G = 4096; // global variable for Right Low IR value
	int MaxHit; // greatest value of left and right light difference
	int SensorVal = 8000; // real-time added value of left and right light difference
	int IR_RightLow_angle; // motor angle when right low IR is hit
	int IR_LeftLow_angle; // motor angle when Left low IR is hit
	int diffLevel_Right_G; // real-time Light diff level of right IR
	int diffLevel_Left_G; // real-time Light diff level of Left IR
	int diffLevel_Right_LowestVal = 0; // value the updates to greatest light difference on right IR
	int diffLevel_Left_LowestVal = 0; // value the updates to greatest light difference on Left IR
	int diffleft; // value the updates to greatest light difference on right IR
	int diffright; // value the updates to greatest light difference on Left IR
	int LEDcount; // count for LED light celebration pattern

	const int OFF = 1;
	const int ON  = 0;
	const int light_threshold_Left = 450;
	const int light_threshold_Right = 600;


	void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed){
		button1_pushed = true;
	}
	if(SensorValue(SwitchRight) && !SwitchRight_pushed)	{
		SwitchRight_pushed = true;
	}
	if(SensorValue(SwitchLeft) && !SwitchLeft_pushed){
		SwitchLeft_pushed = true;
	}
}


bool monitorLight_Right()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int Right_Low = 4096;	// Minimum light level seen by IR sensor 1
	static int Right_High = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevel_Right = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int IR_Right_Value = SensorValue[RightIR];

	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevel_Right = Right_High - Right_Low;
		diffLevel_Right_G = diffLevel_Right;
		// Reset calculation for next 100 msecs.
		Right_High = 0;
		Right_Low = 4096;

		clearTimer(T1);

	} else {

		// Check for new minimum/maximum light levels.
		if(IR_Right_Value > Right_High) {
			Right_High = IR_Right_Value;	
		} else if(IR_Right_Value < Right_Low) {
			Right_Low = IR_Right_Value;
     		Right_Low_G = IR_Right_Value; 
		}
	}
	diffright = diffLevel_Right;
	// Check if light level difference over threshold.
	if ( diffLevel_Right > light_threshold_Right ) {
		returnValue = true;
	} else {
		returnValue = false;
	}

	return(returnValue);
}


bool monitorLight_Left()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int Left_Low = 4096;			// Minimum light level seen by IR sensor 1
	static int Left_High = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevel_Left = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int IR_Left_Value = SensorValue[LeftIR];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T2] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevel_Left = Left_High - Left_Low;
		diffLevel_Left_G = diffLevel_Left;

		// Reset calculation for next 100 msecs.
		Left_High = 0;
		Left_Low = 4096;

		clearTimer(T2);

	} else {

		// Check for new minimum/maximum light levels.
		if(IR_Left_Value > Left_High) {
			Left_High = IR_Left_Value; 
		} else if(IR_Left_Value < Left_Low) {
			Left_Low = IR_Left_Value;
			Left_Low_G = IR_Left_Value; 
		}
	}
	diffleft = diffLevel_Left;
	// Check if light level difference over threshold.
	if ( diffLevel_Left > light_threshold_Left ) {
		returnValue = true;
	} else {
		returnValue = false;
	}

	return(returnValue);
}


void exercise1() {

	bool beaconVisible_Left; //flag for LeftIR receiving beacon light
	bool beaconVisible_Right;  //flag for RightIR receiving beacon light
	int SpeedFactor = 0; //Intial Speed for scanning
	bool IR_FirstHit_Left; // flag for when LeftIR first hits beacon light
	bool IR_FirstHit_Right; // flag for when RightIR first hits beacon light
	bool StartFlag = false;  // flag for the start of program
	bool Near_Beacon = false;
	bool StartTowardsWall = false;
	bool connect = false;


enum T_exercise1_state{
	MOTOR_STOP = 0,
	FIRST_SCAN,
	SCAN_TARGETLEFT,
	SCAN_TARGETRIGHT,
	MOTOR_ADJUSTLEFT,
	MOTOR_ADJUSTRIGHT,
	MOTOR_REVERSE,
	MOTOR_SLOW,
	MOTOR_STRAIGHT,
	FINAL_SCAN,
	SLOW,
	STOP,
	CONNECTION
	};



T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true) {

	monitorInput();
	beaconVisible_Left = monitorLight_Left(); // Returns true value when IR Left is receiving a 10Hz signal from the beacon
	beaconVisible_Right = monitorLight_Right(); //Returns true value when IR Right is receiving a 10Hz signal from the beacon


	if(	SwitchRight_pushed ) { //if right bumper is hit
		clearTimer(T4);
		exercise1_state = MOTOR_ADJUSTLEFT;
	}
	if( SwitchLeft_pushed  ) { //if left bumper is hit
		clearTimer(T4);
		exercise1_state = MOTOR_ADJUSTRIGHT;
	}
	if( SwitchRight_pushed &&	SwitchLeft_pushed ) {//if both bumpers are hit
		clearTimer(T4);
		resetMotorEncoder(motorRight);
		resetMotorEncoder(motorLeft);
		exercise1_state = MOTOR_REVERSE;
	}	//end if
	if( beaconVisible_Left ) {	// flag for when LeftIR first hits beacon light
		IR_FirstHit_Left = true;
	}
	if( beaconVisible_Right ) { // flag for when RightIR first hits beacon light
		IR_FirstHit_Right = true;
	}
	if( diffLevel_Left_G > diffLevel_Left_LowestVal ){  // grabs the greatest light difference from Left IR, lowest value of IR
		diffLevel_Left_LowestVal = diffLevel_Left_G;
	}
	if( diffLevel_Right_G > diffLevel_Right_LowestVal ){ // grabs the greatest light difference from Right IR, lowest value of IR
		diffLevel_Right_LowestVal = diffLevel_Right_G;
	}
	if( beaconVisible_Left && beaconVisible_Right) { // added values of Left and Right greatest light difference for reflection avoidance
		MaxHit =  diffLevel_Right_LowestVal + diffLevel_Left_LowestVal;
	}
	
	SensorVal = diffLevel_Right_G +	diffLevel_Left_G; // real time left and right light difference
	if( !connect && StartFlag && ( SensorValue[Sonar_Sensor] < 18 && SensorValue[Sonar_Sensor] > 0  && SensorVal > 7800 ) ) { //Slows when close to contact
		Near_Beacon = true;
		exercise1_state = FINAL_SCAN;
		Bumper_connection_pushed = false; 
	}

switch (exercise1_state) {


case MOTOR_STOP:
	motor[motorLeft]=0;
	motor[motorRight]=0;
	if( button1_pushed ) { 	// button for starting Scan Left
		IR_FirstHit_Left = false;	//Flags for when Left & Right IR sensors are first hit.
		IR_FirstHit_Right = false;
		StartFlag = true;	// initial falg that signals the start of program; only resets when kill switch is pressed.
		clearTimer(T4);
		resetMotorEncoder(motorRight);
		resetMotorEncoder(motorLeft);
		exercise1_state = FIRST_SCAN;
	}
	if(SensorValue[Sonar_Sensor] < 10 && SensorValue[Sonar_Sensor] >0 && button1_pushed) { // if started facing towards wall, reverse
		StartTowardsWall = true;
		clearTimer(T4);
		exercise1_state = MOTOR_REVERSE; 
	}
break;


case MOTOR_ADJUSTLEFT: //turning left
		SwitchRight_pushed = false;
		Direction = 0;	//set wall direction
		motor[motorRight]=-60;	//back up
		motor[motorLeft]=-5;
		if(time1(T4) > 1500){	//after 1.5 seconds, go to search
			SpeedFactor = 0;
			exercise1_state = SCAN_TARGETLEFT;
		}
break;


case MOTOR_ADJUSTRIGHT:	//turning right
		SwitchLeft_pushed = false;
		Direction = 1;	//set wall direction
		motor[motorRight]=-5;
		motor[motorLeft]=-60;
		if(time1(T4) > 1500){	//after 1.5 seconds, go to search
			SpeedFactor = 0;
			exercise1_state = SCAN_TARGETRIGHT;
		}
break;


case MOTOR_REVERSE:	//reversing
	SwitchRight_pushed = SwitchLeft_pushed = false;
	Direction = 1;
	motor[motorRight]=-40;	//back up
	motor[motorLeft]=-40;
	if(time1(T4) > 1500 && !StartTowardsWall ) { //after 1.5 second, go to search
		SpeedFactor = 0;
		exercise1_state = SCAN_TARGETRIGHT;
	}
	if(StartTowardsWall && time1(T4) > 1500) { // goes to first scan after a start facing a wall
		clearTimer(T4);
		StartTowardsWall = false;
		resetMotorEncoder(motorRight);
		resetMotorEncoder(motorLeft);
		exercise1_state = FIRST_SCAN;
	}
break;


case FIRST_SCAN:
	button1_pushed = false;
	if(time1(T4) < 3000 ) {
		motor[motorRight]=-35;
		motor[motorLeft]=35; //turn Right 180 degrees: 580 at 30 ea side
		if( diffLevel_Right_G > diffLevel_Right_LowestVal && beaconVisible_Right ) {
			Right_Low_G = SensorValue[RightIR];  // highest IR reading
			IR_RightLow_angle = getMotorEncoder(motorRight);
		}
		if( diffLevel_Left_G > diffLevel_Left_LowestVal && beaconVisible_Left ) {
			Left_Low_G = SensorValue[RightIR];  // highest IR reading
			IR_LeftLow_angle = getMotorEncoder(motorLeft);
		}
	}
	if(time1(T4) > 3000 && time1(T4) < 9100 ) {
	  motor[motorRight]=37;
		motor[motorLeft]=-35; //turn Left 180 degrees: 580 at 30 ea side
		if( diffLevel_Right_G > diffLevel_Right_LowestVal && beaconVisible_Right ) {
			Right_Low_G = SensorValue[RightIR];  // highest IR reading
			IR_RightLow_angle = getMotorEncoder(motorRight);
		}
		if( diffLevel_Left_G > diffLevel_Left_LowestVal  && beaconVisible_Left ) {
			Left_Low_G = SensorValue[RightIR];  // highest IR reading
			IR_LeftLow_angle = getMotorEncoder(motorLeft);
		}
	}
	if(time1(T4) > 9100 ) {
		motor[motorRight]=-35;
		motor[motorLeft]=35;
		if( SensorVal > MaxHit - 20 ) { //
			exercise1_state = MOTOR_STRAIGHT;
		}
		if( getMotorEncoder(motorRight) < IR_RightLow_angle + 20 || getMotorEncoder(motorLeft) < IR_LeftLow_angle + 20 ) {
			exercise1_state = MOTOR_STRAIGHT;
		}
  	}
	if(time1(T4) > 18200 ){
	  	clearTimer(T4); 
	}
break;


case SCAN_TARGETLEFT:
		motor[motorLeft]=-30 + SpeedFactor;	// SpeedFactor intially set to Zero for first scan
		motor[motorRight]=35 - SpeedFactor;
		if( IR_FirstHit_Left && beaconVisible_Left && beaconVisible_Right && SensorVal > MaxHit ) { // Stops if lined up with beacon scanning left 																					// Lights up LED that Robot is orietated the right direction of the beacon but too far away
			button1_pushed = false; // resets start button.
			IR_FirstHit_Left = false;  // resets both IR flags in order to know if overswing occurs
			IR_FirstHit_Right = false;
			clearTimer(T4);
			exercise1_state = MOTOR_STRAIGHT; 
		}
		if( IR_FirstHit_Right ){ 	// If it misses the Left IR flag and hits the Right IR flag it will swing back the opposite direction
			exercise1_state = SCAN_TARGETRIGHT;
			IR_FirstHit_Right = false; 
		}
break;


case SCAN_TARGETRIGHT:
		motor[motorLeft]=30 - SpeedFactor;	// SpeedFactor intially set to Zero for first scan
		motor[motorRight]=-35 + SpeedFactor;
		if( IR_FirstHit_Right && beaconVisible_Left && beaconVisible_Right && SensorVal > MaxHit ) {
			button1_pushed = false;	// resets start button.
			IR_FirstHit_Right = false;  // resets both IR flags in order to know if overswing occurs
			IR_FirstHit_Left = false;
			clearTimer(T4);
			exercise1_state = MOTOR_STRAIGHT;
		}
		if( IR_FirstHit_Left ){	// If it misses the right IR flag and hits the left IR flag it will swing back the opposite direction
			exercise1_state = SCAN_TARGETLEFT;
			IR_FirstHit_Left = false;
		}
break;


case MOTOR_STRAIGHT:
		if( time1(T4) > 2000 ) {
			clearTimer(T4);
			IR_FirstHit_Right = false; // resets both IR flags in order to know if overswing occurs
			IR_FirstHit_Left = false;
		}
		if( beaconVisible_Left ) { // flag for when LeftIR first hits beacon light
			IR_FirstHit_Left = true;
		}
		if( beaconVisible_Right ) { // flag for when RightIR first hits beacon light
		  	IR_FirstHit_Right = true;
		}

		if((beaconVisible_Left && !beaconVisible_Right || IR_FirstHit_Left && !IR_FirstHit_Right || diffleft < diffright - 1500 ) && !button1_pushed && StartFlag ) {
			IR_FirstHit_Left = false;
			exercise1_state = SCAN_TARGETLEFT; // three different ways in parallel to catch if robot veers off to the right
			SpeedFactor = 5;
		}
		if((!beaconVisible_Left && beaconVisible_Right || !IR_FirstHit_Left && IR_FirstHit_Right || diffright < diffleft - 1500 ) && !button1_pushed && StartFlag) {
			exercise1_state = SCAN_TARGETRIGHT;
			IR_FirstHit_Right = false;
			SpeedFactor = 5;
		}

		if( beaconVisible_Left && beaconVisible_Right ) {
		 	motor[motorLeft] = 70;	// straight
			motor[motorRight] = 90;
		}
break;

case FINAL_SCAN:
		connect = true;
		if(diffleft > diffright ){ // final scan when in range of beacon
			motor[motorRight] = 24;
			motor[motorLeft] = -21; 
		}

		if(diffright > diffleft ){
			motor[motorRight] = -24;
			motor[motorLeft] = 21; 
		}

		if(time1(T4) > 1500) {
			if(diffleft - diffright < 20 || diffleft - diffright > -20) {
				exercise1_state = SLOW; 
			}
		}
break;

case SLOW:
	motor[motorRight] = 23; // slow stage in lead up to connection
	motor[motorLeft] = 20;
	if(SensorValue[Sonar_Sensor] < 3 && SensorValue[Sonar_Sensor] > 0) {
		exercise1_state = CONNECTION;
		clearTimer(T4); }//if close
break;

case CONNECTION:

	if(time1(T4) < 2000) {
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
		motor[motorCrane] = 20;
		motor[motorCable] = 20; 
	}//if first time period

	if(time1(T4) > 2000 && time1(T1) < 5000) {
		motor[motorCrane] = 0;
		motor[motorCable] = 0;
		motor[motorRight]= motor[motorLeft] = -20; 
	}//if second time period

	if(time1(T4) > 5000) {
		exercise1_state = STOP; 
	}//over 6 seconds
break;


case STOP:
	motor[motorRight]=0;
	motor[motorLeft]=0;
	int n = 36;
	if(LEDcount <= 5) {
		if(time1(T3) < n) {
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > n && time1(T3) < (2*n)) {
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (2*n) && time1(T3) < (3*n)) {
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (3*n) && time1(T3) < (4*n)){
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (4*n) && time1(T3) < (5*n)){
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (5*n) && time1(T3) < (6*n)){
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (6*n)){
			clearTimer(T3);
			LEDcount++;
		}
	}
	if(LEDcount>5&&LEDcount<=15) {
		if(time1(T3) < n){
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (2*n) && time1(T3) < (3*n)) {
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (3*n)) {
			clearTimer(T3);
			LEDcount++;
		}
	}
	
	if(LEDcount > 15 && LEDcount<=20) {
		if(time1(T3) < n) {
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > n && time1(T3) < (2*n)) {
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (2*n) && time1(T3) < (3*n)) {
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (3*n) && time1(T3) < (4*n)){
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (4*n) && time1(T3) < (5*n)){
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (5*n) && time1(T3) < (6*n)){
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (6*n)){
			clearTimer(T3);
			LEDcount++;
		}
	}
	
	if(LEDcount>20&&LEDcount<=31) {
		if(time1(T3) < n){
			SensorValue[LED_1] = ON;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = ON;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = ON;
			SensorValue[LED_6] = OFF;
		}
		if(time1(T3) > (2*n) && time1(T3) < (3*n)) {
			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = ON;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = ON;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = ON;
		}
		if(time1(T3) > (3*n)) {
			clearTimer(T3);
			LEDcount++;
		}
		if(LEDcount >= 30) {
			LEDcount = 0;
		}
}
break;//stop

default:
}//end Switch
}//end While
}//end exercise



task main() {
	while(true){
		switch (EXERCISE_NUMBER) {
	
		case 1:  // IR Sensing Test
			resetMotorEncoder(motorLeft);
			resetMotorEncoder(motorRight);
 			SensorValue[LED_1] = OFF;
			SensorValue[LED_2] = OFF;
			SensorValue[LED_3] = OFF;
			SensorValue[LED_4] = OFF;
			SensorValue[LED_5] = OFF;
			SensorValue[LED_6] = OFF;
			Bumper_connection_pushed = SwitchRight_pushed = SwitchLeft_pushed = button1_pushed = IR_FirstHit_Left = IR_FirstHit_Right = false;
			exercise1();
		break;

		default: //should never get here.
		}//end Switch
	}//end While (true)
}//task main
